use crate::common::{
    ast::*,
    error_formatter::ErrorFormatter,
    visitors::{ExpressionVisitor, StatementVisitor},
};

use std::{collections::HashMap, iter::Peekable, vec::IntoIter};

#[derive(Clone)]
pub struct Symbol {
    constant: bool,
    identifier: Token,
    typing: Type,
}

#[derive(Clone)]
pub enum LeftValue {
    Variable(Symbol),
    Deref {
        base: Expression,
        typing: Type,
        mutable: bool,
    },
    ArrayAccess {
        base: Expression,
        typing: Type,
        mutable: bool,
    },
}

impl LeftValue {
    pub fn is_mutable(&self) -> bool {
        match self {
            LeftValue::Variable(symbol) => !symbol.constant,
            LeftValue::Deref { mutable, .. } => *mutable,
            LeftValue::ArrayAccess { mutable, .. } => *mutable,
        }
    }

    pub fn get_typing(&self) -> &Type {
        match self {
            LeftValue::Variable(symbol) => &symbol.typing,
            LeftValue::Deref { typing, .. } => typing,
            LeftValue::ArrayAccess { typing, .. } => typing,
        }
    }
}

pub struct SymbolTable {
    pub label: Option<String>,
    pub symbols: HashMap<String, Symbol>,
}

impl SymbolTable {
    pub fn new(label: Option<String>) -> Self {
        Self {
            label,
            symbols: HashMap::new(),
        }
    }

    pub fn insert(&mut self, name: &str, symbol: Symbol) -> Result<(), String> {
        if self.symbols.contains_key(name) {
            return Err(format!(
                "symbol '{name}' already defined in scope: {}",
                self.label.clone().unwrap_or("unnamed".to_string())
            ));
        }
        self.symbols.insert(name.to_string(), symbol);
        Ok(())
    }

    pub fn lookup(&self, name: &str) -> Option<Symbol> {
        self.symbols.get(name).cloned()
    }
}

pub struct SemanticAnalyzer {
    program: Peekable<IntoIter<Statement>>,
    pub err_fmt: ErrorFormatter,
    scopes: Vec<SymbolTable>,
}

type SemaStmtResult = Result<Statement, String>;
type SemaExprResult = Result<Expression, String>;

impl StatementVisitor<SemaStmtResult> for SemanticAnalyzer {
    fn visit_stmt(&mut self, stmt: &Statement) -> SemaStmtResult {
        match stmt {
            Statement::DeclareVariable(d) => self.visit_declare_variable_stmt(d),
            Statement::Block(d) => self.visit_block_stmt(d),
            Statement::Expression(d) => self.visit_expression_stmt(d),
        }
    }

    fn visit_declare_variable_stmt(
        &mut self,
        stmt: &DeclareVariableStatementData,
    ) -> SemaStmtResult {
        let mut descriptor_typing: Option<Type> = None;
        if let Some(d) = &stmt.type_descriptor {
            descriptor_typing = Some(Type::from_type_descriptor(d).ok_or_else(|| {
                self.err_fmt.format(
                    d.identifier.span,
                    format!("invalid type provided: '{}'", d.identifier.lexeme),
                )
            })?);
        }

        let mut expr: Option<Expression> = None;
        if let Some(e) = &stmt.value {
            expr = Some(self.visit_expr(e)?);
        }

        let value_typing = expr.as_ref().map(|e| e.get_typing().unwrap());
        if descriptor_typing.is_none() && value_typing.is_none() {
            return Err(self.err_fmt.format(
                stmt.identifier.span,
                "uninitialized variables must have type descriptors.".to_string(),
            ));
        }

        if let (Some(v_type), Some(d_type)) = (value_typing, descriptor_typing.clone())
            && !v_type.is_compatible_with(&d_type)
        {
            return Err(self.err_fmt.format(
                stmt.type_descriptor.as_ref().unwrap().identifier.span,
                format!("type '{}' is not assignable to type '{}'", v_type, d_type),
            ));
        }

        let mut typing = descriptor_typing.clone().or(value_typing.cloned()).unwrap();

        if stmt.constant && (stmt.value.is_none() || typing.is_optional()) {
            return Err(self
                .err_fmt
                .format(stmt.span, "constant cannot be undefined.".to_string()));
        }

        if stmt.value.is_none() && !typing.is_optional() {
            return Err(self.err_fmt.format(
                stmt.span,
                "non-optional variables cannot be undefined.".to_string(),
            ));
        }

        if typing.is_array() {
            let mut descriptor_pointer_data: Option<PointerTypeData> = None;
            let mut value_pointer_data: Option<PointerTypeData> = None;

            if let Some(d) = descriptor_typing {
                if let PointerType::Array(dt) = d.get_type_data().unwrap().pointer.clone().unwrap()
                {
                    descriptor_pointer_data = Some(dt);
                }
            }

            if let Some(d) = &value_typing {
                if let PointerType::Array(dt) = d.get_type_data().unwrap().pointer.clone().unwrap()
                {
                    value_pointer_data = Some(dt);
                }
            }

            if descriptor_pointer_data.clone().is_none_or(|pd| pd.capacity.is_none())
                && value_pointer_data.clone().is_none_or(|pd| pd.capacity.is_none())
            {
                return Err(self.err_fmt.format(
                    stmt.span,
                    "array capacity must be know in comptime.".to_string(),
                ));
            }

            let t = typing.get_mut_type_data().unwrap();
            t.pointer = Some(PointerType::Array(
                if descriptor_pointer_data.clone().is_some_and(|pd| pd.capacity.is_some()) {
                    descriptor_pointer_data.unwrap()
                } else {
                    value_pointer_data.unwrap()
                },
            ));
        }

        let scope = self.current_scope_mut();
        let symbol = Symbol {
            constant: stmt.constant,
            identifier: stmt.identifier.clone(),
            typing: typing.clone(),
        };

        scope
            .insert(&stmt.identifier.lexeme, symbol)
            .map_err(|e| self.err_fmt.format(stmt.identifier.span, e))?;

        let data = DeclareVariableStatementData {
            typing: Some(typing),
            value: expr,
            ..stmt.clone()
        };

        Ok(Statement::DeclareVariable(data))
    }

    fn visit_block_stmt(&mut self, stmt: &BlockStatementData) -> SemaStmtResult {
        let label_opt = stmt.label.as_ref().map(|t| t.lexeme.clone());
        self.open_scope(label_opt.clone());

        let mut tir_stmts = Vec::with_capacity(stmt.statements.len());
        for stmt in stmt.statements.iter() {
            tir_stmts.push(self.visit_stmt(stmt)?);
        }

        self.close_scope();

        let data = BlockStatementData {
            statements: tir_stmts,
            ..stmt.clone()
        };

        Ok(Statement::Block(data))
    }

    fn visit_expression_stmt(&mut self, stmt: &ExpressionStatementData) -> SemaStmtResult {
        let expr = self.visit_expr(&stmt.expr)?;
        let data = ExpressionStatementData {
            typing: expr.get_typing().cloned(),
            expr,
            ..stmt.clone()
        };

        Ok(Statement::Expression(data))
    }
}

impl ExpressionVisitor<SemaExprResult> for SemanticAnalyzer {
    fn visit_expr(&mut self, expr: &Expression) -> SemaExprResult {
        match expr {
            Expression::VariableAssignment(d) => self.visit_variable_assignment_expr(d),
            Expression::Literal(d) => self.visit_literal_expr(d),
            Expression::Identifier(d) => self.visit_identifier_expr(d),
            Expression::ArrayLiteral(d) => self.visit_array_literal_expr(d),
            Expression::ArrayAccess(d) => self.visit_array_access_expr(d),
            Expression::BuiltinCall(d) => self.visit_builtin_call_expr(d),
            Expression::Dereference(d) => self.visit_deref_expr(d),
            Expression::Reference(d) => self.visit_ref_expr(d),
        }
    }

    fn visit_variable_assignment_expr(
        &mut self,
        expr: &VariableAssignmentExpressionData,
    ) -> SemaExprResult {
        let lvalue = self.analyze_left_value(&expr.left)?;

        if !lvalue.is_mutable() {
            return Err(self.err_fmt.format(
                expr.left.get_span(),
                "cannot assign value to constant".to_string(),
            ));
        }

        let value = self.visit_expr(&expr.right)?;
        let value_typing = value.get_typing().unwrap();

        if !value_typing.is_compatible_with(lvalue.get_typing()) {
            return Err(self.err_fmt.format(
                expr.equal.span,
                format!(
                    "type '{}' is not assignable to type '{}'.",
                    value_typing,
                    lvalue.get_typing()
                ),
            ));
        }

        let data = VariableAssignmentExpressionData {
            typing: Some(value_typing.clone()),
            right: Box::new(value),
            ..expr.clone()
        };

        Ok(Expression::VariableAssignment(data))
    }

    fn visit_literal_expr(&mut self, expr: &LiteralExpressionData) -> SemaExprResult {
        let data = LiteralExpressionData {
            typing: Type::from_literal_expr(expr),
            ..expr.clone()
        };

        Ok(Expression::Literal(data))
    }

    fn visit_identifier_expr(&mut self, expr: &IdentifierExpressionData) -> SemaExprResult {
        let symbol = self.lookup(&expr.value.lexeme).ok_or_else(|| {
            self.err_fmt.format(
                expr.value.span,
                format!("undeclared variable: '{}'", expr.value.lexeme),
            )
        })?;

        let data = IdentifierExpressionData {
            typing: Some(symbol.typing),
            ..expr.clone()
        };

        Ok(Expression::Identifier(data))
    }

    fn visit_array_literal_expr(&mut self, expr: &ArrayLiteralExpressionData) -> SemaExprResult {
        let mut expected_typing: Option<Type> = None;
        let mut values: Vec<Expression> = Vec::new();

        for expr in &expr.values {
            let current_expr = self.visit_expr(expr)?;
            let current_typing = current_expr.get_typing().unwrap();

            if (!current_typing.is_undefined() || !current_typing.is_null())
                && expected_typing.is_none()
            {
                expected_typing = Some(current_typing.clone());
            }

            if expected_typing
                .clone()
                .is_some_and(|et| !current_typing.is_compatible_with(&et))
            {
                return Err(self.err_fmt.format(current_expr.get_span(), format!(
                    "the type of this array elements has been inferred as '{}', and type '{}' is not assignable to that.",
                    expected_typing.unwrap(), current_typing
                )));
            }

            values.push(current_expr);
        }

        if expected_typing
            .clone()
            .is_some_and(|t| t.is_undefined() || t.is_null())
        {
            return Err(self.err_fmt.format(
                expr.span,
                "cannot create all-null or all-undefined arrays.".to_string(),
            ));
        }

        if expected_typing.clone().is_none() {
            return Err(self
                .err_fmt
                .format(expr.span, "array type cannot be inferred.".to_string()));
        }

        let pointer_type = PointerType::Array(PointerTypeData {
            capacity: Some(values.len()),
            mutable: true,
            nullable: false,
        });

        let rest = expr.clone();

        let mut expected_typing = expected_typing.unwrap();
        let type_data = expected_typing.get_mut_type_data().unwrap();
        type_data.pointer = Some(pointer_type);

        let data = ArrayLiteralExpressionData {
            values,
            typing: Some(expected_typing),
            ..rest
        };

        Ok(Expression::ArrayLiteral(data))
    }

    fn visit_array_access_expr(&mut self, expr: &ArrayAccessExpressionData) -> SemaExprResult {
        let lvalue = self.analyze_left_value(&expr.left)?;
        if !lvalue.get_typing().is_array() {
            return Err(self.err_fmt.format(
                expr.left.get_span(),
                "cannot index non-array type".to_string(),
            ));
        }

        let index = self.visit_expr(&expr.index)?;
        let index_typing = index.get_typing().unwrap();

        if !index_typing.is_integer() {
            return Err(self.err_fmt.format(
                expr.index.get_span(),
                format!(
                    "array index must be integer type, but received index of type '{}'.",
                    index_typing
                ),
            ));
        }

        let mut value_type = lvalue.get_typing().clone();
        let type_data = value_type.get_mut_type_data().unwrap();
        type_data.pointer = None;

        let data = ArrayAccessExpressionData {
            left: Box::new(self.visit_expr(&expr.left)?),
            index: Box::new(index),
            typing: Some(value_type),
            ..expr.clone()
        };

        Ok(Expression::ArrayAccess(data))
    }

    fn visit_builtin_call_expr(&mut self, expr: &BuiltinCallExpressionData) -> SemaExprResult {
        todo!()
    }

    fn visit_deref_expr(&mut self, expr: &DereferenceExpressionData) -> SemaExprResult {
        let base = self.visit_expr(&expr.identifier)?;
        let base_type = base.get_typing().unwrap();

        if !base_type.is_pointer() {
            return Err(self.err_fmt.format(
                base.get_span(),
                "cannot dereference non-pointer type.".to_string(),
            ));
        }

        let mut t = base_type.clone();
        t.get_mut_type_data().unwrap().pointer = None;

        let data = DereferenceExpressionData {
            identifier: Box::new(base),
            typing: Some(t),
            ..expr.clone()
        };

        Ok(Expression::Dereference(data))
    }

    fn visit_ref_expr(&mut self, expr: &ReferenceExpressionData) -> SemaExprResult {
        let symbol = self.lookup(&expr.identifier.lexeme).ok_or_else(|| {
            self.err_fmt.format(
                expr.identifier.span,
                format!(
                    "cannot create an ref to undeclared variable: '{}'",
                    expr.identifier.lexeme
                ),
            )
        })?;

        let mut typing = symbol.typing;

        if typing.is_null() || typing.is_undefined() || typing.is_pointer() {
            return Err(self.err_fmt.format(
                expr.identifier.span,
                format!("cannot create a reference to type: '{}'.", typing),
            ));
        }

        if expr.mutable && symbol.constant {
            return Err(self.err_fmt.format(
                expr.identifier.span,
                "cannot create mutable reference of constant value.".to_string(),
            ));
        }

        let type_is_array = typing.is_array();
        let type_data = typing.get_mut_type_data().unwrap();
        type_data.pointer = Some(match type_is_array {
            true => PointerType::Fat(PointerTypeData {
                capacity: None,
                mutable: expr.mutable,
                nullable: false,
            }),
            false => PointerType::Thin(PointerTypeData {
                capacity: None,
                mutable: expr.mutable,
                nullable: false,
            }),
        });

        let data = ReferenceExpressionData {
            typing: Some(typing),
            ..expr.clone()
        };

        Ok(Expression::Reference(data))
    }
}

impl SemanticAnalyzer {
    pub fn new(program: Vec<Statement>, source: String, filepath: String) -> Self {
        let scopes = vec![SymbolTable::new(Some("global".to_string()))];

        Self {
            program: program.into_iter().peekable(),
            err_fmt: ErrorFormatter::new("semantic-analyzer", source, filepath),
            scopes,
        }
    }

    fn open_scope(&mut self, label: Option<String>) {
        self.scopes.push(SymbolTable::new(label));
    }

    fn close_scope(&mut self) {
        self.scopes.pop().expect("internal err: pop empty scope.");
    }

    fn current_scope_mut(&mut self) -> &mut SymbolTable {
        self.scopes
            .last_mut()
            .expect("internal err: pop empty scope.")
    }

    fn lookup(&self, name: &str) -> Option<Symbol> {
        for scope in self.scopes.iter().rev() {
            if let Some(s) = scope.lookup(name) {
                return Some(s);
            }
        }
        None
    }

    pub fn analyze(&mut self) -> Result<Vec<Statement>, String> {
        let mut program = Vec::new();

        while let Some(stmt) = self.program.next() {
            let tir_stmt = self.visit_stmt(&stmt)?;
            program.push(tir_stmt);
        }

        Ok(program)
    }

    pub fn analyze_left_value(&mut self, expr: &Expression) -> Result<LeftValue, String> {
        match expr {
            Expression::Identifier(d) => {
                let symbol = self.lookup(&d.value.lexeme).ok_or_else(|| {
                    self.err_fmt.format(
                        d.value.span,
                        format!("cannot assign to undeclared variable: '{}'", d.value.lexeme),
                    )
                })?;

                Ok(LeftValue::Variable(symbol))
            }
            Expression::Dereference(d) => {
                let base = self.visit_expr(&d.identifier)?;
                let base_type = base.get_typing().unwrap();

                if !base_type.is_pointer() {
                    return Err(self.err_fmt.format(
                        base.get_span(),
                        "cannot dereference non-pointer type.".to_string(),
                    ));
                }

                let ptr = base_type.get_type_data().unwrap().pointer.clone().unwrap();
                let (pointee, mutable) = match ptr {
                    PointerType::Thin(p) | PointerType::Fat(p) => {
                        let mut t = base_type.clone();
                        t.get_mut_type_data().unwrap().pointer = None;
                        (t, p.mutable)
                    }
                    _ => unreachable!(),
                };

                Ok(LeftValue::Deref {
                    base,
                    typing: pointee,
                    mutable,
                })
            }
            Expression::ArrayAccess(d) => {
                let base = self.visit_expr(&d.left)?;
                let base_type = base.get_typing().unwrap();

                let index = self.visit_expr(&d.index)?;
                let index_typing = index.get_typing().unwrap();

                if !index_typing.is_integer() {
                    return Err(self.err_fmt.format(
                        index.get_span(),
                        format!(
                            "array index must be integer type, but received index of type '{}'.",
                            index_typing
                        ),
                    ));
                }

                if !base_type.is_array() {
                    return Err(self
                        .err_fmt
                        .format(base.get_span(), "cannot index non-array type".to_string()));
                }

                let ptr = base_type.get_type_data().unwrap().pointer.clone().unwrap();
                let (pointee, mutable) = match ptr {
                    PointerType::Array(p) => {
                        let mut t = base_type.clone();
                        t.get_mut_type_data().unwrap().pointer = None;
                        (t, p.mutable)
                    }
                    _ => unreachable!(),
                };

                Ok(LeftValue::ArrayAccess {
                    base,
                    typing: pointee,
                    mutable,
                })
            }
            _ => Err(self.err_fmt.format(
                expr.get_span(),
                "unexpected left-value expression has provided.".to_string(),
            )),
        }
    }
}
